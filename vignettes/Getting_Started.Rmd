---
title: "Getting Started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, set up, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  results = "hold"
)

library(sizedist)
```

`sizedist`  is an R interface for Stan and provides functions to simulate and fit size and age-structured populations models to data. In this *Getting Started* vignette, we will cover the simplest model that is implemented in the package. `model1` assumes mortality and growth are constants. See the Theory vignette for more details on the various models in `sizedist`

### Simulating age- and size- structured data

To begin, let's first start by simulating some data of a hypothetical population. We first need to set some **hyper-parameters** that are used to inform the simulation. See the XXX vignette on the definitions for each hyperparameter. `sizedist` has default hyper-parameters that you can access using the `default_pars()` function. Note that these hyper-parameters are organised as a **list** object and will also be used during model fitting. Learn more about [lists](https://www.tutorialspoint.com/r/r_lists.html)

```{r hyperparams}
library(sizedist)

#Calling this function will return a list of hyperparameters
#Tip: Assign this function into an object for later use
pars <- default_pars("model1")

pars
```

We can now use these hyperparameters to simulate some data using the `simulate_population()` function.

```{r simulate}
#Tip: Assign this function to an object so you have access to the data
data <- simulate_population(pars)

data
```

We created two plotting functions to visualise the distribution of size and age of the simulated population 

```{r visualise, fig.align = "center"}
plot_age_dist(data, pars, binwidth = 1)
```

### Creating binned data for size

In order to estimate a distribution for size/age in our models, we need  to create bins or 'class intervals' for these variables and tally up the number of observations that fall into each of these bins. The `summarise_bin_counts()` function will do the trick!

```{r age counts}
# Compute bins for age 
age_data <- data %>% summarise_bin_counts(bin_var = age, 
                                          bin_width = 1)

age_data
```

### Compose data for model fitting

`sizedist` relies on Stan for estimating size/age distribution models. Stan requires our input data to be a specific list format. Conveniently, the `compose_count_data()` function will translate your binned data into a list for you. Each column from your bin data is converted into a list element with the same name. Learn more about [lists](https://www.tutorialspoint.com/r/r_lists.html)

```{r compose}
standata_age <- age_data %>% compose_count_data()

str(standata_age) # Ta da! Your binned data is now a list!
```

### Fitting your model 

`sizedist` currently suports three types of models.We will fit `model1_a` which assumes that mortality and growth are constant over time. All models can be viewed using this XXX function. A more detailed overview of each of these models are found in the **Theory vignette**. Before we fit our first model, we need to add some hyper-parameters into our data list. Any relevant hyper-parameters such as the name of the model is added automatically using the `add_pars()` function. 

#### Constant Mortality and Growth model

`sizedist` currently supports three types of models (`model1_a`, `model1_b`, `model1_c`). Models with the prefix `model1_` all have XXX in common. `model1_a` assumes **constant** mortality and growth. In order to fit these different variants of models, you will need to specify the name using the `mutate_pars` function. 

```{r}
(age_pars <- pars %>% mutate_pars(model = "model1_a"))
```

Once the name of the model has been updated, the `pars` object will need to be joined to the data list created above. Note that `add_pars()` will by default, prune the `pars` list to the hyperparamaters that are used in model fitting. 
```{r fit}
standata_age_mod1 <- standata_age %>% add_pars(pars = age_pars) 

str(standata_age_mod1) #Model name is added to the end of the data list
```

```{r, eval = FALSE, results = "hide"}
age_fit <- fit_sizedist(standata_age_mod1)

print(age_fit, probs=c(0.025, 0.5, 0.975))
```

### Other models that are supported in sizedist

#### Constant Mortality, known Growth model

In some instances, a known growth rate found in the literature or other studies can be used to inform the model that is estimating the size distribution. In this example, we will use the simulated size data.

```{r, fig.align='center'}
plot_size_dist(data, pars, binwidth = 0.1)
```

```{r size counts}
# Compute bins for size
size_data <- data %>% summarise_bin_counts(bin_var = size, 
                                          bin_width = 0.1)
# Compose data
standata_size <- size_data %>% compose_count_data()
```

In order to fit the *Constant Mortality, known Growth model* (`model1_b`), we will need to edit the model name and if you want, edit the values  for `g_av` which represents the average growth rate and `s0_av` which represents the average size at hatching/birth.
```{r}
# Assign default parameters into an object
pars  <- default_pars("model1")

pars_cm_kg <- mutate_pars(pars,
                          model = "model1_b",
                          g_av = 0.21,
                          s0_av = 6)

pars_cm_kg
```

Similar to the first example, we will know need to add these hyperparameters to our data list in order to run our model with `add_pars()`.

```{r}
standata_size_mod2 <- standata_size %>% add_pars(pars_cm_kg)

str(standata_size_mod2)
```

```{r, eval = FALSE, results = "hide"}
knowng_fit <- fit_sizedist(standata_size_mod2)

print(knowng_fit, probs=c(0.025, 0.5, 0.975))
```

#### Estimating Growth and Mortality 

The final model that `sizedist` currently supports (`model1_c`) can estimate mortality and growth simultaneously using size and age data. In our simulated dataset, we have information on individual's sizes at particular ages as well as the overall distribution of sizes across the population. These data were simulated with no sampling error. 

```{r, fig.align='center'}
library(ggplot2)

ggplot(data, aes(size, age)) + 
  geom_point()
```

We need to first add some sampling noise to the size observations before we can fit the model using the `add_sampling_noise()` function. Otherwise, the model will have a hard time running! This step is not needed if you are using your own data! See XXX case study. 

```{r, fig.align='center'}
growth_data <- simulate_population(pars) %>% 
  add_sampling_noise(size, sd = 0.5)

ggplot(growth_data, aes(size, age)) + 
  geom_point()
```

Then we can put the growth data in the correct Stan friendly format using `compose_growth_data()`.

```{r}
# Counts data
standata_size <- size_data %>% 
  compose_count_data()

# Growth data
standata_growth <- 
  growth_data %>% 
  compose_growth_data(age_var = age,
                      size_var = size)

str(standata_growth)
```

Now we will bring these data together using `join_stan_data()`

```{r}
# Combining the two types of data lists together
standata_size_growth_mod3 <- join_stan_data(standata_size, standata_growth)

str(standata_size_growth_mod3)
```

To fit this final model (`model1_c`), we will again need to update our hyperparameters and add them to our combined data list before fitting. Again, you can supply your own value for `s0_av` which represents the average size at hatching/birth using `mutate_pars()`

```{r}
pars_m_g <- mutate_pars(pars,
                        model = "model1_c")

pars_m_g 

# Add in hyperparameters to data list
standata_size_growth_mod3 <- standata_size_growth_mod3 %>% add_pars(pars_m_g)
str(standata_size_growth_mod3)
```

```{r, eval = TRUE, results="hide"}
m_g_fit <- fit_sizedist(standata_size_growth_mod3)

print(m_g_fit, probs=c(0.025, 0.5, 0.975))
```


### Model fit diagnostics

Once the models have been fit, we can extract posteriors and run diagnostics to assess model fitting. Here, we focus on output from the model estimating growth and mortality simultaneously  (`model3`), but the process is the same for each of the three models. 

We recommend are several CRAN packages that are wonderful for interacting with Stan model fit objects and visualising model diagnostics

```{r}
library(ggplot2) 
library(rstan)
library(bayesplot)
library(patchwork)
```

#### Model convergence 
First, we observe the mean estimate for each coefficient. Note the Gelman–Rubin statistic (Rhat) to assess convergence. Is it > or = 1?

```{r, eval = FALSE}
print(m_g_fit, probs=c(0.025, 0.5, 0.975))
```

Next, we can plot the trace chains to see if they converged or not. Are some chains getting stuck? What you want to see here is all four chains to eventually overlap each other across most of the iterations
```{r, fig.align='center', fig.width=7, fig.height=4}
p_trace <- rstan::traceplot(m_g_fit, pars = c("Z", "g", "R"), 
                            inc_warmup = TRUE) +
  xlab("Iteration") +
  ylab("Parameter estimate") 
  
p_trace
```

#### No-U-Turn-Sampler (NUTS) energy diagnostics

- The first histogram uses the function `mcmc_nuts_energy()`
Produces overlaid histograms showing energy__ πE (i.e., the value of the Hamiltonian (up to an additive constant) at each sample) vers the change in energy__ πΔE (See Betancourt (2016) for details.) In the figure, we want to *see if the histograms for πE and πΔE are approximately equal*. If the distribution of πΔE has deviated from πE (e.g., wider tails) then autocorrelation of the chains will be large. For more details check out this [paper](https://arxiv.org/abs/1604.00695).

The remaining histograms uses the function`mcmc_scatter()`
This function produces bivariate scatterplots of the MCMC draws, with the divergent chains highlighted. Here we are checking to *see if the divergent chains are clustered in parameter space*. If the divergent chains are spread out, then they are most probably false positive results and can be discounted. If the divergences are clustered, it is indicative that sampling has not computed a reliable answer. More details on why the scatter plot with divergences is a useful diagnostic tool can be found in [Gabry et al. (2019)](https://rss.onlinelibrary.wiley.com/doi/full/10.1111/rssa.12378).

```{r, message=FALSE, fig.align='center', fig.height=6, fig.width=7}
color_scheme_set("red")
np <- nuts_params(m_g_fit)

nuts_1 <- mcmc_nuts_energy(np) + ggtitle("NUTS Energy Diagnostic")

color_scheme_set("darkgray")
nuts_2 <- mcmc_scatter(
  as.matrix(m_g_fit),
  pars = c("g", "Z"), 
  np = nuts_params(m_g_fit), 
  np_style = scatter_style_np(div_color = "green", div_alpha = 0.8)
)

nuts_3 <- mcmc_scatter(
  as.matrix(m_g_fit),
  pars = c("Z", "R"), 
  np = nuts_params(m_g_fit), 
  np_style = scatter_style_np(div_color = "green", div_alpha = 0.8)
)

nuts_4 <- mcmc_scatter(
  as.matrix(m_g_fit),
  pars = c("R", "g"), 
  np = nuts_params(m_g_fit), 
  np_style = scatter_style_np(div_color = "green", div_alpha = 0.8)
)

nuts_1 / (nuts_2 + nuts_3 + nuts_4)
```

Further methods, examples and discussion of MCMC diagnostics is provided by Gabry and Modrák (2021) in <https://mc-stan.org/bayesplot/articles/visual-mcmc-diagnostics.html>

#### ShinysStan
A GUI is available for the diagnostic analysis and visualisation for MCMC from stan. Using ShinyStan allows for the exploration of stan output through your web browser. See <https://mc-stan.org/users/interfaces/shinystan>
```{r}
library(shinystan)

launch_shinystan(m_g_fit)
```

#### Distribution of posteriors of each parameter estimate

What are the things we should look out for? 
- Sensibly behaved - biomodal or multimodel will need careful assessment - Expect unimodal unless a priori expectation?
- Are range of values on X axis expected?

```{r, fig.align='center', fig.height=5, fig.width=7}
posterior <- as.matrix(m_g_fit)

plot_title <- ggtitle("Posterior distributions",
                      "with medians and 89% intervals")
post_1 <- mcmc_areas(posterior, 
              pars = c("Z"),
              prob = 0.89) + plot_title

post_2 <-mcmc_areas(posterior, 
           pars = c("g"),
           prob = 0.89) + plot_title

post_3 <- mcmc_areas(posterior, 
           pars = c("R"),
           prob = 0.89) + plot_title

post_1 + post_2 + post_3
```

#### Plot Fitted estimates with data.

Then we can plot the fitted estimates to simulated data. 
`plot_size_dist()` allows you to add a fitted line based on new model estimates to the previous size-frequency histogram.

How well does the fitted line match the data?

```{r, eval = TRUE, fig.align='center'}
# extract posterior mean estimates
fit_Z_size <- mean(rstan::extract(m_g_fit, pars="Z")[["Z"]])
fit_R_size <- mean(rstan::extract(m_g_fit, pars="R")[["R"]])
fit_g_size <- mean(rstan::extract(m_g_fit, pars="g")[["g"]])

# fitted values for plotting
fitted <- list(
              R = fit_R_size,
              s0_av = pars_m_g$s0_av,
              z_av = fit_Z_size,
              g_av = fit_g_size,
              binwidth = 0.1,
              model = "model1_c"
)

# Plot fitted values on data
plot_size_dist(growth_data, pars_m_g, binwidth = 0.1, fitted)
```

We can also fit the growth model estimates to data, including posterior draws. 
```{r, fig.align='center'}
# extract posterior draws
dat <- m_g_fit %>% 
  rstan::extract() %>%
  as.data.frame() 

dat2 <- dat %>%
 dplyr::slice(which(dplyr::row_number() %% 3 == 1)) #thin data 

# Can we just use samp_frac for the above?
# dat_2 <- dat %>% sample_frac(0.30)

draw_g <- dat2$g

#select data for plotting
s0 = pars_m_g$s0_av #size at hatching

#plot
p <- ggplot(growth_data, aes(x= age, y = size)) + 
  geom_point(size = 2, alpha = 0.8) +
  theme_bw() + 
  xlab("Age") +
  ylab("Size")

  
for(i in seq_len(nrow(dat2))) {
  p <- p + geom_abline(intercept = s0, slope = draw_g[i], col = "blue", alpha = 0.1) #fit posterior draws
  }

p <- p +
  geom_abline(intercept = s0, slope = fit_g_size, col = "red") #mean fit 
p
```



