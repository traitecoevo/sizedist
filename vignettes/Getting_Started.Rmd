---
title: "Getting Started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, set up, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  results = "hold"
)

library(sizedist)
```

`sizedist`  is an R interface for Stan and provides functions to simulate and fit size and age-structured populations models to data. In this *Getting Started* vignette, we will cover the simplest model that is implemented in the package. `model1` assumes mortality and growth are constants. See the Theory vignette for more details on the various models in `sizedist`

### Simulating age structureded data

To begin, let's first start by simulating some data of a hypothetical population. We first need to set some **hyper-parameters** that are used to inform the simulation. See the XXX vignette on the definitions for each hyperparameter. `sizedist` has default hyper-parameters that you can access using the `default_pars()` function. Note that these hyper-parameters are organised as a **list** object and will also be used during model fitting. Learn more about [lists](https://www.tutorialspoint.com/r/r_lists.html)
```{r hyperparams}
library(sizedist)

#Calling this function will return a list of hyperparameters
#Tip: Assign this function into an object for later use
pars <- default_pars("model1")

pars
```

We can now use these hyperparameters to simulate some data using the `simulate_population()` function.

```{r simulate}
#Tip: Assign this function to an object so you have access to the data
data <- simulate_population(pars)

data
```

We created two plotting functions to visualise the distribution of size and age of the simulated population 

```{r visualise, fig.align = "center"}
plot_age_dist(data, pars, binwidth = 1)
```

### Creating binned data for and size

In order to estimate a distribution for size/age in our models, we need  to create bins or 'class intervals' for these variables and tally up the number of observations that fall into each of these bins. The `summarise_bin_counts()` function will do the trick!

```{r age counts}
# Compute bins for age 
age_data <- data %>% summarise_bin_counts(bin_var = age, 
                                          bin_width = 1)

age_data
```

### Compose data for model fitting

`sizedist` relies on Stan for estimating size/age distribution models. Stan requires our input data to be a specific list format. Conveniently, the `compose_count_data()` function will translate your binned data into a list for you. Each column from your bin data is converted into a list element with the same name. Learn more about [lists](https://www.tutorialspoint.com/r/r_lists.html)

```{r compose}
standata_age <- age_data %>% compose_count_data()

str(standata_age) # Ta da! Your binned data is now a list!
```

### Fitting your model 

`sizedist` currently suports three types of models.We will fit `model1` which assumes that mortality and growth are constant over time. All models can be viewed using this XXX function. A more detailed overview of each of these models are found in the **Theory vignette**. Before we fit our first model, we need to add some hyper-parameters into our data list. Any relevant hyper-parameters such as the name of the model is added automatically using the `add_pars()` function. 

#### Constant Mortality and Growth model

```{r fit}
standata_age_mod1 <- standata_age %>% add_pars(pars = default_pars("model1")) 

str(standata_age_mod1) #Model name is added to the end of the data list
```

```{r, eval = FALSE, results = "hide"}
age_fit <- fit_sizedist(standata_age_mod1)

print(age_fit, probs=c(0.025, 0.5, 0.975))
```

### Other models that are supported in sizedist

#### Constant Mortality, known Growth model

In some instances, a known growth rate found in the literature or other studies can be used to inform the model that is estimating XXX. In this example, we will use the simulated size data.

```{r, fig.align='center'}
plot_size_dist(data, pars, binwidth = 0.1)
```

```{r size counts}
# Compute bins for size
size_data <- data %>% summarise_bin_counts(bin_var = size, 
                                          bin_width = 0.1)
# Compose data
standata_size <- size_data %>% compose_count_data()
```

In order to fit the *Constant Mortality, known Growth model*, we will need to edit the model name and add in our `known_g` value using `mutate_pars()`.
```{r}
# Assign default parameters into an object
p  <- default_pars("model1")

p_cm_kg <- mutate_pars(p,
                       model = "model2",
                       known_g = 0.21)

p_cm_kg
```

Similar to the first example, we will know need to add these hyperparameters to our data list in order to run our model with `add_pars()` 

```{r}
standata_size_mod2 <- standata_size %>% add_pars(p_cm_kg)

str(standata_size_mod2)
```

```{r, eval = FALSE, results = "hide"}
knowng_fit <- fit_sizedist(standata_size_mod2)

print(knowng_fit, probs=c(0.025, 0.5, 0.975))
```

#### Estimating mortality and growth simultaneously

The final model that `sizedist` currently supports (`model3`) can estimate mortality and growth using size and age data. In our simulated dataset, we have information on individual's sizes at particular ages as well as the overall distribution of sizes across the population. We first need to put the growth data in the correct Stan friendly format using `compose_growth_data()`.

```{r}
# Counts data
standata_size <- size_data %>% 
  compose_count_data()

# Growth data
standata_growth <- data %>% compose_growth_data(age_var = age, 
                                                size_var = size)

str(standata_growth)
```

Now we will bring these data together using `join_stan_data()`

```{r}
# Combining the two types of data lists together
standata_size_growth_mod3 <- join_stan_data(standata_size, standata_growth)

str(standata_size_growth_mod3)
```

To fit this final model (`model3`), we will again need to update our hyperparameters and add them to our combined data list before fitting. 

```{r}
p_m_g <- mutate_pars(p,
                     model = "model3")

p_m_g 

# Add in hyperparameters to data list
standata_size_growth_mod3 <- standata_size_growth_mod3 %>% add_pars(p_m_g)
str(standata_size_growth_mod3)
```

```{r, eval = FALSE}
m_g_fit <- fit_sizedist(standata_size_growth_mod3)
```



### TBC for visualing fits and getting coefficients and posteriors etc- Charlie to do

Packages for diagnostic plots

```{r}
source("R/plot_size_dist.R") #reload because changes made to function
library(ggplot2) #required for plot_size_dist()
library(rstan) # loading for traceplot()
library(bayesplot) # for mcmc_areas()
```


Once the models have been fit, we can extract posteriors and run diagnostics to assess model fitting. Here, we focus on output from the model estimating growth and mortality simultaneously  (`model3`), but the process is the same for each of the three models. 

First, we observe the mean estimate for each coefficient. Note the Gelmanâ€“Rubin statistic (Rhat) to assess convergence. Is it > or = 1?
```{r, eval = FALSE}
print(m_g_fit, probs=c(0.025, 0.5, 0.975))
```

Next, plot trace chains - have they converged? Are they getting stuck?
```{r}
p_trace <- traceplot(m_g_fit, pars = c("Z", "g", "R"), 
          inc_warmup = TRUE) +
  xlab("Iteration") +
  ylab("Parameter estimate") 
  
p_trace
```

No-U-Turn-Sampler (NUTS) energy diagnostics
```{r}
color_scheme_set("red")
np <- nuts_params(m_g_fit)
mcmc_nuts_energy(np) + ggtitle("NUTS Energy Diagnostic")


color_scheme_set("darkgray")
mcmc_scatter(
  as.matrix(m_g_fit),
  pars = c("g", "Z"), 
  np = nuts_params(m_g_fit), 
  np_style = scatter_style_np(div_color = "green", div_alpha = 0.8)
)

mcmc_scatter(
  as.matrix(m_g_fit),
  pars = c("Z", "R"), 
  np = nuts_params(m_g_fit), 
  np_style = scatter_style_np(div_color = "green", div_alpha = 0.8)
)


mcmc_scatter(
  as.matrix(m_g_fit),
  pars = c("R", "g"), 
  np = nuts_params(m_g_fit), 
  np_style = scatter_style_np(div_color = "green", div_alpha = 0.8)
)
```

Plot distribution of posteriors
```{r}
posterior <- as.matrix(m_g_fit)

plot_title <- ggtitle("Posterior distributions",
                      "with medians and 89% intervals")
mcmc_areas(posterior, 
           pars = c("Z"),
           prob = 0.89) + plot_title

mcmc_areas(posterior, 
           pars = c("g"),
           prob = 0.89) + plot_title

mcmc_areas(posterior, 
           pars = c("R"),
           prob = 0.89) + plot_title
```


Then we can plot the fitted estimates to data. plot_size_dist() allows you to add a fitted line based on new model estimates to the previous size-frequency histogram  
```{r, eval = FALSE}
#extract mean estimates
fit_Z_size <- mean(rstan::extract(m_g_fit, pars="Z")[["Z"]])
fit_R_size <- mean(rstan::extract(m_g_fit, pars="R")[["R"]])
fit_g_size <- mean(rstan::extract(m_g_fit, pars="g")[["g"]])

# fitted values for plotting
fitted <- list(
              R = fit_R_size,
              s0_av = pars$s0_av,
              z_av = fit_Z_size,
              g_av = fit_g_size,
              binwidth = 0.1,
              model = "model1"
)

#plot fitted values on data
plot_size_dist(data, p, binwidth = 0.1, fitted)
```

We can also fit the growth model estimates to data, including posterior draws. Note, we did not add variance to g so each draw will have the same estimate. 
```{r}
# extract posterior draws
dat <- m_g_fit %>% extract() %>%
  as.data.frame()

dat2 <- dat %>%
 dplyr::slice(which(dplyr::row_number() %% 3 == 1)) #thin data


draw_g <- dat2$g

#select data for plotting
growth_data <- data.frame(age = standata_growth$age,
                 size_ind = standata_growth$size_ind)

s0 = 3

#plot
p <- ggplot(growth_data, aes(x= age, y = size_ind)) + 
  geom_point(size = 5, alpha = 0.8) +
  theme_bw() + 
  xlab("age (days)") +
  ylab("length (mm)")
  
  
for(i in seq_len(nrow(dat2))) {
  p <- p + geom_abline(intercept = s0, slope = draw_g[i], col = "blue", alpha = 0.1) #fit posterior draws
  }

p <- p +
  geom_abline(intercept = s0, slope = fit_g_size, col = "red") #mean fit 
p
```



